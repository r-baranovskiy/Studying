# iOS Guide

## Классы и Структуры

### Структуры:

- Имеют встроенный инициализатор
- Структуры не могут наследовать
- Изменение типов данных в структуре осуществляется с помощью ключевого слово mutating
- Структуры хранятся в стеке

По умолчанию Apple рекомендует использовать структуры. Структуры также полезны в следующих сценариях:
- Используйте структуры для простых типов данных. Воспринимайте их как простые базы данных, которые вы можете использовать в своем коде. Поскольку они четко определены и часто не нуждаются в сложных отношениях между объектами.
- В многопоточной среде, например, с подключением к базе данных в другом потоке, структуры более безопасны. и могут быть безопасно скопированы из одного потока в другой. Классы не имеют присущей им безопасности, если только они не намеренно сделаны поточно-ориентированными.
- Когда свойства структуры в основном являются значимыми типами, например String, имеет смысл обернуть их в структуру вместо класса.

Использование структур имеет дополнительное преимущество - вам проще анализировать изменения данных в вашем коде. Когда тип является структурой, вы можете быть уверены, что никакая другая часть вашего кода не сможет удерживать ссылку на объект. То есть структура не может быть изменена какой-либо другой частью вашего кода.


## Классы:

У классов есть несколько дополнительных характеристик, которых нет у структур:
- Классы могут наследоваться друг от друга.
- Классы могут быть деинициализированы.
- Классы поставляются со встроенным понятием идентичности, потому что они
являются ссылочными типами.
- Классы хранятся в куче (heap)

С помощью оператора идентичности === вы можете проверить, ссылаются ли два экземпляра класса на один и тот же объект.
Наследование является наиболее важным различием между классом и структурой. С помощью классов вы можете четко определить родительско - дочернюю связь между подклассом и суперклассом.

[Классы и Структуры](https://swiftblog.org/klassy-i-struktury/)



## Объектно-ориентированное программирование (ООП)

ООП - помогает структурировать код с помощью классов. Классы имеют свойства и методы, которые могут наследоваться друг от друга.
ООП как стиль написания программ подразумевает построение структуры, состоящей из взаимодействующих объектов. В рамках ООП нужно мыслить объектами. Объекты расположены в иерархии, самостоятельны и как-то взаимодействуют. Программа состоит из модулей – блоков, которые решают какие-то задачи. Изменения в этих участках могут не отражаться на других участках.

Главные принципы в ООП – абстракция, полиморфизм, наследование, инкапсуляция.


### Абстракция 

У объекта есть «протокол»: у объекта есть методы и свойства, к которым мы можем обратиться извне этого объекта. Так же, как мы можем нажать кнопку на блендере. У блендера есть много всего внутри, что заставляет его работать, но на главной панели есть только кнопка. Вот эта кнопка и есть абстрактный интерфейс.

В программе мы можем сказать: «Удалить пользователя». На языке ООП это будет «пользователь.удалить ()» — то есть мы обращаемся к объекту «пользователь» и вызываем метод «удалить». Кайф в том, что нам не так важно, как именно будет происходить удаление: ООП позволяет нам не думать об этом в момент обращения. Например, над магазином работают два программиста: один пишет модуль заказа, а второй — модуль доставки. У первого в объекте «заказ» есть метод «отменить». И вот второму нужно из-за доставки отменить заказ. И он спокойно пишет: «заказ.отменить ()».
Ему неважно, как другой программист будет реализовывать отмену: какие он отправит письма, что запишет в базу данных, какие выведет предупреждения.


### Полиморфизм

Возможность объектов с одинаковым описанием метода иметь различную реализацию этого метода.

Полиморфизм - реализуется через
- базовый класс UIView у которого есть куча наследников, а функция принимает UIView, поэтому мы можем работать со всеми наследниками.
- Дженерики, функция принимает T тип и принт печатает его на экран
- Протоколы
Полиморфный код - код который может работать с различными типами.
Целью полиморфизма является использование одного имени для задания общих для класса действий. Выполнение каждого конкретного действия будет определяться типом данных. Концепцией полиморфизма является идея «один интерфейс, множество методов». Это означает, что можно создать общий интерфейс для группы близких по смыслу действий. Преимуществом полиморфизма является то, что он помогает понизить сложность разработки, разрешая использование того же интерфейса для задания единого класса действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор.


### Наследование

Cправляется с дублированием кода. Процесс, посредством которого один объект может приобретать свойства другого. Точнее, объект может наследовать основные свойства другого объекта и добавлять к ним черты, характерные только для него. Польза наследования в том, что оно дополняет идею абстракции. Абстракция позволяет представить объекты с разным уровнем детальности. Наследование упрощает программирование, позволяя создать универсальные методы для выполнения всего, что основано на общих свойствах, и затем написать специфические методы для выполнения специфических операций над конкретными типами данных.


### Агрегация

Тип отношений, когда у класса объект, позаимствовал где-то еще Композиция - это такой тип отношений, когда класс владеет объектом и несет ответственность за нее.


### Инкапсуляция

Заключение данных и функционала в оболочку. В объектно-ориентированном программировании в роли оболочки выступают классы: они не только собирают переменные и методы в одном месте, но и защищают их от вмешательства извне (сокрытие).


[Полиморфизм](https://forum.swiftbook.ru/t/polimorfizm-v-swift/2714/3)

[ООП](https://swiftblog.org/obektno-orientirovannoe-programmirovanie-v-swift/)



## Принципы SOLID

### DRY - Do not repeat yourself - Не повторяйся!
### KISS - Keep It Small and Simple - Будь проще!
### YAGNI - You aren't gonna need it - Вам это не понадобится!

Принципы SOLID - основополагающие принципы, на которых строятся архитектуры. Вот как расшифровывается акроним SOLID:


### S: Single Responsibility Principle (Принцип единой ответственности).
Один класс должен решать только какую-то одну задачу, одна ответственность на один класс. Он может иметь несколько методов, но они должны использоваться лишь для решения общей задачи. Все методы и свойства должны служить одной цели. Если класс имеет несколько назначений, его нужно разделить на отдельные классы.

### O: Open-Closed Principle (Принцип открытости-закрытости).
 Должны быть открыты для расширения, но закрыты для изменения.
 Программные сущности (классы, модули, функции и прочее) должны быть расширяемыми без изменения своего содержимого. Если строго соблюдать этот принцип, то можно регулировать поведение кода без изменения самого исходника.
 
### L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
Функции, сущности которые используют родительский тип, должны так же работать с дочерними классами. Наследуемый класс должен дополнять, а не замещать поведение базового класса.

### I: Interface Segregation Principle (Принцип разделения интерфейса).
Программные сущности не должны зависеть от методов, которые они не используют Это означает, что нужно разбивать интерфейсы(протоколы) на более мелкие, лучше удовлетворяющие конкретным потребностям клиентов.

### D: Dependency Inversion Principle (Принцип инверсии зависимостей).
«Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»
Проще говоря: зависьте от абстракций, а не от чего-то конкретного.
Применяя этот принцип, одни модули можно легко заменять другими, всего лишь меняя модуль зависимости, и тогда никакие перемены в низкоуровневом модуле не повлияют на высокоуровневый.


[Single Responsibility Principle (Принцип единой ответственности)](https://vmityuklyaev.medium.com/%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%82-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-solid-%D0%B2-swift-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-%D0%B5%D0%B4%D0%B8%D0%BD%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9-%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-f019d6daab2d)

[Open-Closed Principle (Принцип открытости-закрытости)](https://vmityuklyaev.medium.com/solid-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D0%B8-%D0%B7%D0%B0%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D0%B8-%D0%B2-swift-open-closed-principle-in-swift-fd7290fe7456)

[Liskov Substitution Principle (Принцип подстановки Барбары Лисков)](https://vmityuklyaev.medium.com/%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%82-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-solid-%D0%B2-swift-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-%D0%BF%D0%BE%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8-%D0%B1%D0%B0%D1%80%D0%B1%D0%B0%D1%80%D1%8B-%D0%BB%D0%B8%D1%81%D0%BA%D0%BE%D0%B2-a6284b529456)

[Interface Segregation Principle (Принцип разделения интерфейса)](https://vmityuklyaev.medium.com/%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%82-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-solid-%D0%B2-swift-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%BE%D0%B2-isp-1b0d1ea9f7c2)

[Dependency Inversion Principle (Принцип инверсии зависимостей)](https://apptractor.ru/info/articles/printsipy-solid-v-swift.html)

[Принципы чистого кода](https://habr.com/ru/company/itelma/blog/546372/)
